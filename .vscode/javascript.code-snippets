{
  // === SUPABASE DATABASE SNIPPETS ===
  "Supabase Query": {
    "prefix": "sb-query",
    "body": [
      "const { data, error } = await supabase",
      "  .from('$1')",
      "  .select('$2')",
      "  ${3:.limit(10)};",
      "",
      "if (error) {",
      "  logger.error('Query error:', error);",
      "  throw error;",
      "}",
      "",
      "return data;"
    ],
    "description": "Basic Supabase query template"
  },
  "Supabase Insert": {
    "prefix": "sb-insert",
    "body": [
      "const { data, error } = await supabase",
      "  .from('$1')",
      "  .insert($2)",
      "  .select();",
      "",
      "if (error) {",
      "  logger.error('Insert error:', error);",
      "  throw error;",
      "}",
      "",
      "return data;"
    ],
    "description": "Supabase insert template"
  },
  "Supabase Update": {
    "prefix": "sb-update",
    "body": [
      "const { data, error } = await supabase",
      "  .from('$1')",
      "  .update($2)",
      "  .eq('${3:id}', ${4:value})",
      "  .select();",
      "",
      "if (error) {",
      "  logger.error('Update error:', error);",
      "  throw error;",
      "}",
      "",
      "return data;"
    ],
    "description": "Supabase update template"
  },
  "Supabase Delete": {
    "prefix": "sb-delete",
    "body": [
      "const { data, error } = await supabase",
      "  .from('$1')",
      "  .delete()",
      "  .eq('${2:id}', ${3:value})",
      "  .select();",
      "",
      "if (error) {",
      "  logger.error('Delete error:', error);",
      "  throw error;",
      "}",
      "",
      "return data;"
    ],
    "description": "Supabase delete template"
  },
  "Geospatial Query": {
    "prefix": "sb-geo",
    "body": [
      "const { data, error } = await supabase",
      "  .rpc('get_nearby_resources', {",
      "    lat: $1,",
      "    lng: $2,",
      "    radius_meters: ${3:10000}",
      "  });",
      "",
      "if (error) {",
      "  logger.error('Geospatial query error:', error);",
      "  throw error;",
      "}",
      "",
      "return data;"
    ],
    "description": "Geospatial query template"
  },
  "Express Route Handler": {
    "prefix": "route-handler",
    "body": [
      "export const $1 = async (req, res, next) => {",
      "  try {",
      "    const $2 = req.${3:body};",
      "    ",
      "    // TODO: Add validation",
      "    ",
      "    // TODO: Add business logic",
      "    ",
      "    res.status(${4:200}).json({",
      "      success: true,",
      "      data: $5",
      "    });",
      "  } catch (error) {",
      "    next(error);",
      "  }",
      "};"
    ],
    "description": "Express route handler template"
  },
  "Error Response": {
    "prefix": "error-response",
    "body": [
      "return res.status($1).json({",
      "  success: false,",
      "  error: {",
      "    message: '$2',",
      "    code: '$3'",
      "  }",
      "});"
    ],
    "description": "Error response template"
  },
  "Logger": {
    "prefix": "log",
    "body": ["logger.${1|info,error,warn,debug|}('$2', ${3:data});"],
    "description": "Logger template"
  },
  "Cache Get": {
    "prefix": "cache-get",
    "body": [
      "const cached = await CacheModel.get('$1');",
      "if (cached) {",
      "  return cached;",
      "}",
      "",
      "// Fetch fresh data",
      "const data = $2;",
      "",
      "// Cache with TTL",
      "await CacheModel.set('$1', data, ${3:3600}); // ${3:3600} seconds",
      "",
      "return data;"
    ],
    "description": "Cache get/set pattern"
  },
  "Validation Schema": {
    "prefix": "joi-schema",
    "body": [
      "import Joi from 'joi';",
      "",
      "export const $1Schema = Joi.object({",
      "  $2: Joi.string().required()$3",
      "});"
    ],
    "description": "Joi validation schema"
  },
  "Model Method": {
    "prefix": "model-method",
    "body": [
      "static async $1($2) {",
      "  const { data, error } = await supabase",
      "    .from('$3')",
      "    .$4;",
      "",
      "  if (error) {",
      "    logger.error('$1 error:', error);",
      "    throw error;",
      "  }",
      "",
      "  return data;",
      "}"
    ],
    "description": "Model method template"
  },
  // Advanced Backend Patterns (inspired by your TS project)
  "Express Middleware with Error Handling": {
    "prefix": "middleware",
    "body": [
      "/**",
      " * $1 middleware",
      " * @param {import('express').Request} req",
      " * @param {import('express').Response} res",
      " * @param {import('express').NextFunction} next",
      " */",
      "export const $1 = async (req, res, next) => {",
      "  try {",
      "    $2",
      "    next();",
      "  } catch (error) {",
      "    logger.error('$1 middleware error:', error);",
      "    next(error);",
      "  }",
      "};"
    ],
    "description": "Express middleware with JSDoc and error handling"
  },

  "API Controller with Validation": {
    "prefix": "controller",
    "body": [
      "/**",
      " * $1 controller",
      " * @param {import('express').Request} req",
      " * @param {import('express').Response} res",
      " * @param {import('express').NextFunction} next",
      " */",
      "export const $1 = async (req, res, next) => {",
      "  try {",
      "    // Validate input",
      "    const { error, value } = $2Schema.validate(req.${3:body});",
      "    if (error) {",
      "      return res.status(400).json({",
      "        success: false,",
      "        error: error.details[0].message",
      "      });",
      "    }",
      "",
      "    // Business logic",
      "    const result = await $4;",
      "",
      "    res.status(${5:200}).json({",
      "      success: true,",
      "      data: result",
      "    });",
      "  } catch (error) {",
      "    next(error);",
      "  }",
      "};"
    ],
    "description": "API controller with validation and proper response structure"
  },

  "Service Layer Function": {
    "prefix": "service",
    "body": [
      "/**",
      " * $1 service function",
      " * @param {Object} params - Parameters",
      " * @param {string} params.$2 - $3",
      " * @returns {Promise<Object>} Result data",
      " * @throws {Error} When operation fails",
      " */",
      "export const $1Service = async ({ $2 }) => {",
      "  try {",
      "    logger.info('$1Service called with:', { $2 });",
      "",
      "    // Validate inputs",
      "    if (!$2) {",
      "      throw new Error('$2 is required');",
      "    }",
      "",
      "    // Main logic",
      "    $4",
      "",
      "    logger.info('$1Service completed successfully');",
      "    return result;",
      "  } catch (error) {",
      "    logger.error('$1Service error:', error);",
      "    throw error;",
      "  }",
      "};"
    ],
    "description": "Service layer function with JSDoc, logging, and error handling"
  },

  "Database Model Method": {
    "prefix": "model-method",
    "body": [
      "/**",
      " * $1",
      " * @param {Object} data - Input data",
      " * @returns {Promise<Object>} Query result",
      " */",
      "static async $1(data) {",
      "  try {",
      "    const { data: result, error } = await supabase",
      "      .from('$2')",
      "      .$3;",
      "",
      "    if (error) {",
      "      logger.error('$1 error:', error);",
      "      throw new Error(`$1 failed: ${error.message}`);",
      "    }",
      "",
      "    return result;",
      "  } catch (error) {",
      "    logger.error('$1 database error:', error);",
      "    throw error;",
      "  }",
      "}"
    ],
    "description": "Database model method with proper error handling and JSDoc"
  },

  "Async/Await with Error Handling": {
    "prefix": "async-try",
    "body": [
      "/**",
      " * $1",
      " * @param {Object} params - Parameters",
      " * @returns {Promise<Object>} Result",
      " */",
      "const $1 = async (params) => {",
      "  try {",
      "    $2",
      "    return result;",
      "  } catch (error) {",
      "    logger.error('$1 error:', error);",
      "    throw new Error(`$1 failed: ${error.message}`);",
      "  }",
      "};"
    ],
    "description": "Async function with proper error handling and JSDoc"
  },

  "Environment Configuration": {
    "prefix": "env-config",
    "body": [
      "/**",
      " * $1 configuration",
      " * @type {Object}",
      " */",
      "export const $1Config = {",
      "  $2: process.env.$3 || '$4',",
      "  $5: parseInt(process.env.$6, 10) || $7,",
      "  $8: process.env.$9 === 'true',",
      "  ",
      "  // Validation",
      "  validate() {",
      "    const required = ['$3'];",
      "    const missing = required.filter(key => !process.env[key]);",
      "    ",
      "    if (missing.length > 0) {",
      "      throw new Error(`Missing required environment variables: ${missing.join(', ')}`);",
      "    }",
      "  }",
      "};"
    ],
    "description": "Environment configuration with validation"
  },

  "Custom Error Class": {
    "prefix": "custom-error",
    "body": [
      "/**",
      " * Custom $1 error class",
      " * @extends Error",
      " */",
      "export class $1Error extends Error {",
      "  /**",
      "   * @param {string} message - Error message",
      "   * @param {number} statusCode - HTTP status code",
      "   * @param {Object} details - Additional error details",
      "   */",
      "  constructor(message, statusCode = 500, details = {}) {",
      "    super(message);",
      "    this.name = '$1Error';",
      "    this.statusCode = statusCode;",
      "    this.details = details;",
      "    this.timestamp = new Date().toISOString();",
      "    ",
      "    // Capture stack trace",
      "    if (Error.captureStackTrace) {",
      "      Error.captureStackTrace(this, $1Error);",
      "    }",
      "  }",
      "",
      "  /**",
      "   * Convert to JSON for API responses",
      "   * @returns {Object} JSON representation",
      "   */",
      "  toJSON() {",
      "    return {",
      "      name: this.name,",
      "      message: this.message,",
      "      statusCode: this.statusCode,",
      "      details: this.details,",
      "      timestamp: this.timestamp",
      "    };",
      "  }",
      "}"
    ],
    "description": "Custom error class with proper structure and methods"
  },

  "API Response Helper": {
    "prefix": "api-response",
    "body": [
      "/**",
      " * API response helpers",
      " */",
      "export const ApiResponse = {",
      "  /**",
      "   * Success response",
      "   * @param {import('express').Response} res",
      "   * @param {Object} data",
      "   * @param {string} message",
      "   * @param {number} statusCode",
      "   */",
      "  success(res, data = null, message = 'Success', statusCode = 200) {",
      "    return res.status(statusCode).json({",
      "      success: true,",
      "      message,",
      "      data,",
      "      timestamp: new Date().toISOString()",
      "    });",
      "  },",
      "",
      "  /**",
      "   * Error response",
      "   * @param {import('express').Response} res",
      "   * @param {string} message",
      "   * @param {number} statusCode",
      "   * @param {Object} details",
      "   */",
      "  error(res, message = 'Internal Server Error', statusCode = 500, details = {}) {",
      "    return res.status(statusCode).json({",
      "      success: false,",
      "      error: {",
      "        message,",
      "        statusCode,",
      "        details",
      "      },",
      "      timestamp: new Date().toISOString()",
      "    });",
      "  }",
      "};"
    ],
    "description": "API response helper functions with consistent structure"
  },

  // === ADVANCED BACKEND PATTERNS (From TS/Next.js projects) ===
  "Express Route Handler with Validation": {
    "prefix": "route-handler",
    "body": [
      "/**",
      " * $1 route handler",
      " * @param {import('express').Request} req",
      " * @param {import('express').Response} res",
      " * @param {import('express').NextFunction} next",
      " */",
      "export const $2 = async (req, res, next) => {",
      "  try {",
      "    // Validate request",
      "    const { error, value } = ${3:validationSchema}.validate(req.${4:body});",
      "    if (error) {",
      "      return ApiResponse.error(res, error.details[0].message, 400);",
      "    }",
      "",
      "    // Process request",
      "    $5",
      "",
      "    // Return success response",
      "    return ApiResponse.success(res, result, '$6');",
      "  } catch (error) {",
      "    logger.error('Error in $2:', error);",
      "    next(error);",
      "  }",
      "};"
    ],
    "description": "Express route handler with validation and error handling"
  },

  "Database Service Class": {
    "prefix": "service-class",
    "body": [
      "/**",
      " * $1 Service Class",
      " * Handles business logic for $2 operations",
      " */",
      "export class $1Service {",
      "  /**",
      "   * @param {Object} supabase - Supabase client",
      "   * @param {Object} logger - Logger instance",
      "   */",
      "  constructor(supabase, logger) {",
      "    this.supabase = supabase;",
      "    this.logger = logger;",
      "    this.tableName = '$3';",
      "  }",
      "",
      "  /**",
      "   * Get all records with pagination",
      "   * @param {Object} options - Query options",
      "   * @returns {Promise<Object>} Result with data and metadata",
      "   */",
      "  async getAll(options = {}) {",
      "    try {",
      "      const { page = 1, limit = 10, ...filters } = options;",
      "      const offset = (page - 1) * limit;",
      "",
      "      let query = this.supabase",
      "        .from(this.tableName)",
      "        .select('*', { count: 'exact' })",
      "        .range(offset, offset + limit - 1);",
      "",
      "      // Apply filters",
      "      Object.entries(filters).forEach(([key, value]) => {",
      "        if (value !== undefined) {",
      "          query = query.eq(key, value);",
      "        }",
      "      });",
      "",
      "      const { data, error, count } = await query;",
      "",
      "      if (error) throw error;",
      "",
      "      return {",
      "        data,",
      "        metadata: {",
      "          page,",
      "          limit,",
      "          total: count,",
      "          totalPages: Math.ceil(count / limit)",
      "        }",
      "      };",
      "    } catch (error) {",
      "      this.logger.error(`Error in ${this.tableName} getAll:`, error);",
      "      throw error;",
      "    }",
      "  }",
      "",
      "  /**",
      "   * Get record by ID",
      "   * @param {string} id - Record ID",
      "   * @returns {Promise<Object>} Record data",
      "   */",
      "  async getById(id) {",
      "    try {",
      "      const { data, error } = await this.supabase",
      "        .from(this.tableName)",
      "        .select('*')",
      "        .eq('id', id)",
      "        .single();",
      "",
      "      if (error) throw error;",
      "      return data;",
      "    } catch (error) {",
      "      this.logger.error(`Error in ${this.tableName} getById:`, error);",
      "      throw error;",
      "    }",
      "  }",
      "",
      "  /**",
      "   * Create new record",
      "   * @param {Object} data - Record data",
      "   * @returns {Promise<Object>} Created record",
      "   */",
      "  async create(data) {",
      "    try {",
      "      const { data: result, error } = await this.supabase",
      "        .from(this.tableName)",
      "        .insert(data)",
      "        .select()",
      "        .single();",
      "",
      "      if (error) throw error;",
      "      return result;",
      "    } catch (error) {",
      "      this.logger.error(`Error in ${this.tableName} create:`, error);",
      "      throw error;",
      "    }",
      "  }",
      "",
      "  /**",
      "   * Update record",
      "   * @param {string} id - Record ID",
      "   * @param {Object} data - Update data",
      "   * @returns {Promise<Object>} Updated record",
      "   */",
      "  async update(id, data) {",
      "    try {",
      "      const { data: result, error } = await this.supabase",
      "        .from(this.tableName)",
      "        .update(data)",
      "        .eq('id', id)",
      "        .select()",
      "        .single();",
      "",
      "      if (error) throw error;",
      "      return result;",
      "    } catch (error) {",
      "      this.logger.error(`Error in ${this.tableName} update:`, error);",
      "      throw error;",
      "    }",
      "  }",
      "",
      "  /**",
      "   * Delete record",
      "   * @param {string} id - Record ID",
      "   * @returns {Promise<boolean>} Success status",
      "   */",
      "  async delete(id) {",
      "    try {",
      "      const { error } = await this.supabase",
      "        .from(this.tableName)",
      "        .delete()",
      "        .eq('id', id);",
      "",
      "      if (error) throw error;",
      "      return true;",
      "    } catch (error) {",
      "      this.logger.error(`Error in ${this.tableName} delete:`, error);",
      "      throw error;",
      "    }",
      "  }",
      "}"
    ],
    "description": "Complete database service class with CRUD operations"
  },

  "Validation Schema (Joi)": {
    "prefix": "joi-schema",
    "body": [
      "import Joi from 'joi';",
      "",
      "/**",
      " * $1 validation schema",
      " */",
      "export const $2Schema = Joi.object({",
      "  ${3:name}: Joi.string().required().min(1).max(255),",
      "  ${4:email}: Joi.string().email().required(),",
      "  ${5:age}: Joi.number().integer().min(0).max(120).optional(),",
      "  $0",
      "});",
      "",
      "/**",
      " * $1 update validation schema",
      " */",
      "export const $2UpdateSchema = $2Schema.fork([${6:'name', 'email'}], (schema) => schema.optional());"
    ],
    "description": "Joi validation schema with update variant"
  },

  "Async Error Handler": {
    "prefix": "async-handler",
    "body": [
      "/**",
      " * Async error handler wrapper",
      " * Catches async errors and passes them to Express error handler",
      " * @param {Function} fn - Async function to wrap",
      " * @returns {Function} Express middleware function",
      " */",
      "export const asyncHandler = (fn) => {",
      "  return (req, res, next) => {",
      "    Promise.resolve(fn(req, res, next)).catch(next);",
      "  };",
      "};"
    ],
    "description": "Async error handler wrapper for Express routes"
  },

  "Rate Limiter Middleware": {
    "prefix": "rate-limiter",
    "body": [
      "import rateLimit from 'express-rate-limit';",
      "",
      "/**",
      " * $1 rate limiter",
      " * Limits requests to prevent abuse",
      " */",
      "export const $2RateLimit = rateLimit({",
      "  windowMs: ${3:15} * 60 * 1000, // $3 minutes",
      "  max: ${4:100}, // Limit each IP to $4 requests per windowMs",
      "  message: {",
      "    success: false,",
      "    error: {",
      "      message: 'Too many requests, please try again later.',",
      "      statusCode: 429",
      "    },",
      "    timestamp: new Date().toISOString()",
      "  },",
      "  standardHeaders: true, // Return rate limit info in headers",
      "  legacyHeaders: false, // Disable X-RateLimit-* headers",
      "  handler: (req, res) => {",
      "    logger.warn(`Rate limit exceeded for IP: ${req.ip}`);",
      "    res.status(429).json({",
      "      success: false,",
      "      error: {",
      "        message: 'Too many requests, please try again later.',",
      "        statusCode: 429",
      "      },",
      "      timestamp: new Date().toISOString()",
      "    });",
      "  }",
      "});"
    ],
    "description": "Rate limiter middleware with custom error handling"
  },

  "Database Transaction": {
    "prefix": "db-transaction",
    "body": [
      "/**",
      " * Execute database transaction",
      " * @param {Function} callback - Transaction callback function",
      " * @returns {Promise<any>} Transaction result",
      " */",
      "async function executeTransaction(callback) {",
      "  const client = await supabase.auth.admin.createUser();",
      "  ",
      "  try {",
      "    // Begin transaction",
      "    await client.query('BEGIN');",
      "    ",
      "    // Execute callback with transaction client",
      "    const result = await callback(client);",
      "    ",
      "    // Commit transaction",
      "    await client.query('COMMIT');",
      "    ",
      "    return result;",
      "  } catch (error) {",
      "    // Rollback transaction on error",
      "    await client.query('ROLLBACK');",
      "    logger.error('Transaction failed:', error);",
      "    throw error;",
      "  } finally {",
      "    // Release client",
      "    client.release();",
      "  }",
      "}",
      "",
      "// Usage example:",
      "const result = await executeTransaction(async (client) => {",
      "  $1",
      "  return ${2:result};",
      "});"
    ],
    "description": "Database transaction wrapper with proper error handling"
  },

  "Event Emitter Pattern": {
    "prefix": "event-emitter",
    "body": [
      "import { EventEmitter } from 'events';",
      "",
      "/**",
      " * $1 Event Emitter",
      " * Handles $2 events",
      " */",
      "class $3EventEmitter extends EventEmitter {",
      "  constructor() {",
      "    super();",
      "    this.setMaxListeners(50); // Increase if needed",
      "  }",
      "",
      "  /**",
      "   * Emit $4 event",
      "   * @param {Object} data - Event data",
      "   */",
      "  emit$5(data) {",
      "    this.emit('$6', {",
      "      ...data,",
      "      timestamp: new Date().toISOString()",
      "    });",
      "  }",
      "",
      "  /**",
      "   * Listen for $4 events",
      "   * @param {Function} handler - Event handler",
      "   */",
      "  on$5(handler) {",
      "    this.on('$6', handler);",
      "  }",
      "",
      "  /**",
      "   * Remove $4 event listener",
      "   * @param {Function} handler - Event handler to remove",
      "   */",
      "  off$5(handler) {",
      "    this.off('$6', handler);",
      "  }",
      "}",
      "",
      "// Export singleton instance",
      "export const $7Events = new $3EventEmitter();"
    ],
    "description": "Event emitter pattern for decoupled communication"
  },

  "Cache Helper": {
    "prefix": "cache-helper",
    "body": [
      "/**",
      " * Cache helper utilities",
      " */",
      "export class CacheHelper {",
      "  /**",
      "   * @param {Object} cacheClient - Cache client (Redis, etc.)",
      "   * @param {Object} logger - Logger instance",
      "   */",
      "  constructor(cacheClient, logger) {",
      "    this.cache = cacheClient;",
      "    this.logger = logger;",
      "    this.defaultTTL = 300; // 5 minutes",
      "  }",
      "",
      "  /**",
      "   * Get or set cache value",
      "   * @param {string} key - Cache key",
      "   * @param {Function} fetchFn - Function to fetch data if not cached",
      "   * @param {number} ttl - Time to live in seconds",
      "   * @returns {Promise<any>} Cached or fresh data",
      "   */",
      "  async getOrSet(key, fetchFn, ttl = this.defaultTTL) {",
      "    try {",
      "      // Try to get from cache",
      "      const cached = await this.get(key);",
      "      if (cached !== null) {",
      "        this.logger.debug(`Cache hit for key: ${key}`);",
      "        return cached;",
      "      }",
      "",
      "      // Fetch fresh data",
      "      this.logger.debug(`Cache miss for key: ${key}`);",
      "      const freshData = await fetchFn();",
      "",
      "      // Store in cache",
      "      await this.set(key, freshData, ttl);",
      "",
      "      return freshData;",
      "    } catch (error) {",
      "      this.logger.error(`Cache operation failed for key ${key}:`, error);",
      "      // Return fresh data if cache fails",
      "      return await fetchFn();",
      "    }",
      "  }",
      "",
      "  /**",
      "   * Get value from cache",
      "   * @param {string} key - Cache key",
      "   * @returns {Promise<any|null>} Cached value or null",
      "   */",
      "  async get(key) {",
      "    try {",
      "      const value = await this.cache.get(key);",
      "      return value ? JSON.parse(value) : null;",
      "    } catch (error) {",
      "      this.logger.error(`Cache get failed for key ${key}:`, error);",
      "      return null;",
      "    }",
      "  }",
      "",
      "  /**",
      "   * Set value in cache",
      "   * @param {string} key - Cache key",
      "   * @param {any} value - Value to cache",
      "   * @param {number} ttl - Time to live in seconds",
      "   * @returns {Promise<boolean>} Success status",
      "   */",
      "  async set(key, value, ttl = this.defaultTTL) {",
      "    try {",
      "      await this.cache.setex(key, ttl, JSON.stringify(value));",
      "      return true;",
      "    } catch (error) {",
      "      this.logger.error(`Cache set failed for key ${key}:`, error);",
      "      return false;",
      "    }",
      "  }",
      "",
      "  /**",
      "   * Delete value from cache",
      "   * @param {string} key - Cache key",
      "   * @returns {Promise<boolean>} Success status",
      "   */",
      "  async del(key) {",
      "    try {",
      "      await this.cache.del(key);",
      "      return true;",
      "    } catch (error) {",
      "      this.logger.error(`Cache delete failed for key ${key}:`, error);",
      "      return false;",
      "    }",
      "  }",
      "",
      "  /**",
      "   * Generate cache key",
      "   * @param {string} prefix - Key prefix",
      "   * @param {...any} parts - Key parts",
      "   * @returns {string} Generated cache key",
      "   */",
      "  generateKey(prefix, ...parts) {",
      "    return `${prefix}:${parts.join(':')}`;",
      "  }",
      "}"
    ],
    "description": "Cache helper class with get-or-set pattern"
  }
}
